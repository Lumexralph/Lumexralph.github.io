<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  <title>Olumide | Lumex Portfolio</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="review of a binary search trees using Go">
  <meta name="author" content="Olumide Ogundele">
  <meta name="generator" content="Hugo 0.62.0" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://lumexralph.github.io./plugins/bootstrap/bootstrap.min.css ">
  
  <link rel="stylesheet" href="https://lumexralph.github.io./plugins/slick/slick.css ">
  
  <link rel="stylesheet" href="https://lumexralph.github.io./plugins/themify-icons/themify-icons.css ">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://lumexralph.github.io./css/style.min.css" integrity="" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://lumexralph.github.io./images/favicon.png " type="image/x-icon">
  <link rel="icon" href="https://lumexralph.github.io./images/favicon.png " type="image/x-icon">

  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156681647-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156681647-1');
</script>


</head><body>
<!-- preloader start -->
<div class="preloader">
</div>
<!-- preloader end -->
<header class="navigation fixed-top">
  <nav class="navbar navbar-expand-lg navbar-dark">
    <a class="navbar-brand" href="https://lumexralph.github.io./"><img src="https://lumexralph.github.io./images/logo_2.png" alt="Olumide | Lumex Portfolio"></a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navigation"
      aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse text-center" id="navigation">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item active">
          <a class="nav-link" href="https://lumexralph.github.io./"> Home </a>
        </li>
        
        
        <li class="nav-item">
          <a class="nav-link" href="https://lumexralph.github.io./about">About</a>
        </li>
        
        
        
        <li class="nav-item">
          <a class="nav-link" href="https://lumexralph.github.io./blog">Blog</a>
        </li>
        
        
        
        <li class="nav-item">
          <a class="nav-link" href="https://lumexralph.github.io./contact">Contact</a>
        </li>
        
        
      </ul>
    </div>
  </nav>
</header>

  
<section class="page-title bg-primary position-relative overflow-hidden">
  <div class="container">
    <div class="row">
      <div class="col-12 text-center">
        <h1 class="text-white font-tertiary">Data Structures: Binary Search Trees with Go</h1>
      </div>
    </div>
  </div>
  
  <img src="/images/illustrations/page-title.svg" alt="illustrations" class="bg-shape-1 w-100">
  <img src="/images/illustrations/leaf-pink-round.svg" alt="illustrations" class="bg-shape-2">
  <img src="/images/illustrations/dots-cyan.svg" alt="illustrations" class="bg-shape-3">
  <img src="/images/illustrations/leaf-orange.svg" alt="illustrations" class="bg-shape-4">
  <img src="/images/illustrations/leaf-yellow.svg" alt="illustrations" class="bg-shape-5">
  <img src="/images/illustrations/dots-group-cyan.svg" alt="illustrations" class="bg-shape-6">
  <img src="/images/illustrations/leaf-cyan-lg.svg" alt="illustrations" class="bg-shape-7">
</section>



  <section class="section">
    <div class="container">
      <div class="row">
        <div class="col-lg-12">
          
          <h5 class="font-secondary">Published on Sep 20, 2020 by <span class="text-primary">Olumide Ogundele</span></h5>
          <div class="content">
            <img src="https://lumexralph.github.io./images/blog/binary-search-tree.png" alt="post-thumb" class="img-fluid rounded center mr-5 mb-4">
            <p>In continuation of this exciting quest to learn more about data structures and algorithms. I will love to talk about binary search trees which builds on the knowledge last discussed on linked-list which is referenced from this <a href="https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202">book</a>, you can find the post <a href="https://lumexralph.github.io./blog/linked-list/">here</a>.</p>
<h4 id="why-binary-search-trees">Why Binary Search Trees?</h4>
<p>There are some data structures that allow fast search or flexible update, but not both. An unsorted, doubly-linked lists supports insertion in constant time <code>O(1)</code>  but search took linear time <code>O(n)</code> in the worse case. Sorted arrays support binary search which helps lookup in logarithm time <code>O(logn)</code>, but at the cost of linear-time update.</p>
<p>Binary Search Trees will allow us to have a fast search and update in logarithm time <code>O(logn)</code> but there is a caveat to this which will be explained later when we talk about balancing a binary search tree.</p>
<p>The arrangement and balancing of the tree is done in a way that the keys of nodes on the left subtrees are less than the keys on the right subtrees and this leads to the tree being sorted always.</p>
<h4 id="implementation-of-binary-search-trees">Implementation of Binary Search Trees</h4>
<p>To create a binary search tree, we need a linked list with 2 pointers per node.
The idea is that there is left subtree and right subtree and the node is labelled with a key. I will implement the following operations on the binary search tree: Searching, Traversal and Insertion.</p>
<p>The nodes of the tree have 1. left pointer 2. right pointer 3. optional parent pointer 4. data field, where we store values inserted. All the code and tests to this implementation can be found here on <a href="https://github.com/Lumexralph/go-datastructures-algorithms/tree/master/dataStructures/binarySearchTree">github</a>.</p>
<p>To create a binary search tree, you will need to have a <code>root</code> where everything builds from, it can be empty or it can consist of a node together with 2 binary search trees called left and right subtrees which consists of nodes, a node (tree) which is the smallest unit and foundation of a binary search tree as shown below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// Tree is the basic structure or node in a binary search tree.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Tree</span> <span style="color:#66d9ef">struct</span> {
        <span style="color:#a6e22e">parent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>  <span style="color:#75715e">// parent can be nil i.e Root tree
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">left</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>  <span style="color:#75715e">// left child or left subtree
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">right</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>  <span style="color:#75715e">// right child or right subtree
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Item</span>   <span style="color:#66d9ef">string</span> <span style="color:#75715e">// data held by the node
</span><span style="color:#75715e"></span>    }
</code></pre></div><p>The parent can be a tree but in the case of a root tree, it will be empty and the left and right can also be empty which indicates we are at the end of the tree. We will model a Dictionary (collection of sorted words in ascending order) using this data structure.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// BinarySearchTree to store the words of a dictionary.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BinarySearchTree</span> <span style="color:#66d9ef">struct</span> {
        <span style="color:#a6e22e">Root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>
    }
</code></pre></div><h4 id="insertion">Insertion</h4>
<p>I have 2 different implementations for the insertion operation, the recursive and non-recursive approach.</p>
<h5 id="non-recursive">Non-Recursive</h5>
<p>This approach is more code and a bit easier to reason about. We will starting looking going through the binary search tree from the root and then based on the item to be inserted, we have the following decision points and this also forms the concept behind the recursive approach:</p>
<ul>
<li>
<p>If the root is empty, insert the item there by creating a new tree, where parent, left and right subtree or children are nil.</p>
</li>
<li>
<p>If the item to be inserted is less than the current item in the node, we move to the left subtree and continue our search till we get to the end of the left-subtree i.e nil, then we inserted a new item there encapsulated as a new tree.</p>
</li>
<li>
<p>If the item to be inserted is greater than the current item in the node, repeat the above step but instead of moving to the left subtree, we move to the right subtree.</p>
</li>
</ul>
<p>This is illustrated below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">NormalInsert</span>(<span style="color:#a6e22e">item</span> <span style="color:#66d9ef">string</span>) {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Tree</span>{
                <span style="color:#a6e22e">Item</span>: <span style="color:#a6e22e">item</span>,
            }
            <span style="color:#66d9ef">return</span>
        }
        <span style="color:#a6e22e">currentTree</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span>

    <span style="color:#a6e22e">insertionLoop</span>:
        <span style="color:#66d9ef">for</span> {
            <span style="color:#66d9ef">switch</span> {
            <span style="color:#75715e">// go to the left subtree
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">item</span> &lt; <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">Item</span>:
                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// at the end of the left subtrees
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// attach the new node
</span><span style="color:#75715e"></span>                    <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">left</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Tree</span>{
                        <span style="color:#a6e22e">Item</span>:   <span style="color:#a6e22e">item</span>,
                        <span style="color:#a6e22e">parent</span>: <span style="color:#a6e22e">currentTree</span>,
                    }
                    <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">insertionLoop</span>
                } <span style="color:#66d9ef">else</span> {
                    <span style="color:#a6e22e">currentTree</span> = <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">left</span>
                }
                <span style="color:#66d9ef">break</span>
            <span style="color:#75715e">// go to the right subtree
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">item</span> &gt; <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">Item</span>:
                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// at the end of the right subtree
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// attach the new node
</span><span style="color:#75715e"></span>                    <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">right</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Tree</span>{
                        <span style="color:#a6e22e">Item</span>:   <span style="color:#a6e22e">item</span>,
                        <span style="color:#a6e22e">parent</span>: <span style="color:#a6e22e">currentTree</span>,
                    }
                    <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">insertionLoop</span>
                } <span style="color:#66d9ef">else</span> {
                    <span style="color:#a6e22e">currentTree</span> = <span style="color:#a6e22e">currentTree</span>.<span style="color:#a6e22e">right</span>
                }
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">default</span>:
                <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">insertionLoop</span>
            }
        }
    }
</code></pre></div><p>We needed a label on the loop because when we <code>break</code> in a switch statement, it breaks out of the switch and not the loop.</p>
<h5 id="recursive">Recursive</h5>
<p>Just as discussed above, this approach is less code but takes a little to reason about especially when you get to point where you want to attach the new tree to its parent, it follows same approach above.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">RecursiveInsert</span>(<span style="color:#a6e22e">currentTree</span> <span style="color:#f92672">*</span><span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>, <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">parent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) {
        <span style="color:#75715e">// currentTree is a pointer to the memory location(also a pointer) where the current node tree
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// is stored. This is needed because, when we get to a tree that is empty and we need to insert
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the new item, we&#39;ll need to replace the empty space (which is to hold a tree) with the new tree, this warrants having access to the location.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// If you don&#39;t do this, your update will be detached from the main binary search tree.
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// when we have come to the end of the search.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">newTree</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Tree</span>{
                <span style="color:#a6e22e">Item</span>:   <span style="color:#a6e22e">item</span>,
                <span style="color:#a6e22e">left</span>:   <span style="color:#66d9ef">nil</span>,
                <span style="color:#a6e22e">right</span>:  <span style="color:#66d9ef">nil</span>,
                <span style="color:#a6e22e">parent</span>: <span style="color:#a6e22e">parent</span>,
            }
            <span style="color:#75715e">// Attach to its parent, by getting the memory location where the currentTree.
</span><span style="color:#75715e"></span>            <span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span> = <span style="color:#a6e22e">newTree</span>
            <span style="color:#66d9ef">return</span>
        }

        <span style="color:#75715e">// Recursively search for where to put the item.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">item</span> &lt; (<span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span>).<span style="color:#a6e22e">Item</span> { <span style="color:#75715e">// diverge to the left subtree
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">RecursiveInsert</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span>).<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">item</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span>)
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">RecursiveInsert</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span>).<span style="color:#a6e22e">right</span>, <span style="color:#a6e22e">item</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">currentTree</span>)
        }
    }
</code></pre></div><p>Attaching the new node to the tree takes constant time but the search operation that is performed before the node is attached uses a running time of <code>O(h)</code>, <strong>h - the height of the tree</strong></p>
<p>Note that the insertion here doesn’t guarantee a balanced search tree, this will be discussed in another post when I discuss the Red-Black Tree and Slay Tree which is guaranteed to be <code>O(logn)</code> in height and that applies for insertion, update and deletion, the tree responds to mutation to make it close to being balanced to  guarantee the height of the tree is always or close to <code>O(log n)</code>.</p>
<p>What we have so far is a random binary search tree that is good too but if the insertion goes south (which we don’t have control over the values or items inserted by the user), we can end up in a O(n) height for the tree.</p>
<h5 id="searching">Searching</h5>
<p>It is important to label a binary search tree so that we can uniquely identify each tree using their identifier.</p>
<p>These are the steps to consider when performing this operation:</p>
<ol>
<li>Start the search at the root of the tree</li>
<li>If the search has a key to be searched for;</li>
<li>Check if the key is greater or less than the key or identifier in the root, this will determine if we’ll go down the left child of the tree or the right.</li>
<li>Continue these steps recursively till you find the item or get to the end of the tree</li>
</ol>
<p>The search algorithm runs in <code>O(h)</code> time, where <strong>h is the height of the binary search tree</strong></p>
<p>Finding the minimum node in the tree comes with the understanding that, the leftmost subtree has the minimum item and also for maximum, the rightmost subtree has the highest item in the tree. The smallest key must reside in the left subtree of the root, since all keys in the left subtree have values less than that of the root and the largest key resides in the right subtrees since the keys in the right subtrees are higher than the root. These operations are illustrated below:</p>
<p>Search:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// Search searches for an item, it expects to start from the Root.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">item</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {

        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span>, <span style="color:#a6e22e">item</span>); <span style="color:#a6e22e">result</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// found!
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Item</span>
        }
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
    }
</code></pre></div><p>Minimum:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">FindMinimum</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span> {
        <span style="color:#75715e">// start from the Root and move to the left subtrees
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">minTree</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span>

        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">minTree</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">minTree</span> = <span style="color:#a6e22e">minTree</span>.<span style="color:#a6e22e">left</span>
        }
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">minTree</span>
    }
</code></pre></div><p>Maximum:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// FindMaximum returns the largest or highest item item in the tree.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">FindMaximum</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span> {
        <span style="color:#75715e">// start from the Root and move right wards
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">maxTree</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">Root</span>

        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">maxTree</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">maxTree</span> = <span style="color:#a6e22e">maxTree</span>.<span style="color:#a6e22e">right</span>
        }
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxTree</span>
    }
</code></pre></div><h4 id="traversal">Traversal</h4>
<p>It is about visiting all the nodes in a rooted binary tree, this is a very important part of many algorithms. This is also a foundation to traversing the nodes and edges in a graph.</p>
<p>It comes with the understanding that the elements in the binary search tree are already sorted since the smallest keys are on the left of the root and largest keys are on the right of the root tree.</p>
<p>This is achieved by using a recursive approach visiting the nodes of the tree, processing the left trees, processing the item on that tree and also visiting the right subtrees recursively. The order in which this operation is done leads to 1. In-order traversal 2. Pre-order traversal 3. Post-order traversal</p>
<h5 id="in-order-traversal">In-order traversal:</h5>
<p>Traverse the left subtrees, process the item and traverse the right subtrees, the index of the recursion will be when we reach the leaf or node with no children i.e left and right tree are nil.</p>
<h5 id="pre-order-traversal">Pre-order traversal:</h5>
<p>Process the item in the tree first, then Traverse the left subtrees and traverse the right subtrees</p>
<h5 id="post-order-traversal">Post-order traversal:</h5>
<p>Traverse the left subtrees first, then traverse the right subtrees and then process the item in the tree.</p>
<p>Pre-order and Post-order traversal come in handy when the binary search tree represents an arithmetic expression or a logical expression where order of operation is very important.</p>
<p>The running time of traversal is linear <code>O(n)</code>  because each item is visited once.</p>
<p>Below is the illustration of In-order traversal, you can get the implementation of Pre-order and Post-order on <a href="https://github.com/Lumexralph/go-datastructures-algorithms/tree/master/dataStructures/binarySearchTree">github</a>:</p>
<p>In-order Traversal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// InOrderTraversal traverse in the order [smallest ... largest] [allLeft ... allRight]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BinarySearchTree</span>) <span style="color:#a6e22e">InOrderTraversal</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>, <span style="color:#a6e22e">processItem</span> <span style="color:#66d9ef">func</span> (<span style="color:#66d9ef">string</span>)) {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">InOrderTraversal</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">processItem</span>)
            <span style="color:#75715e">// process the item in the tree using the power of closure
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">processItem</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Item</span>)
            <span style="color:#a6e22e">bt</span>.<span style="color:#a6e22e">InOrderTraversal</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">right</span>, <span style="color:#a6e22e">processItem</span>)
        }
}
</code></pre></div><h4 id="final-thoughts">Final Thoughts</h4>
<blockquote>
<p>Picking the wrong data structure for the job can be disastrous in terms of performance. Identifying the very best data structure is usually not as critical, because there can be several choices that perform similarly. - Steven S. Skiena</p>
</blockquote>
<p>The problem you are trying to solve, will and should always inform the kind of data structure you use. It is a learning journey as always, I will be glad to hear from you if you have question(s) or feedback, have fun!</p>

          </div>
        </div>
      </div>
    </div>
  </section>



<section class="section section-on-footer" data-background="https://lumexralph.github.io./images/backgrounds/bg-dots.png">
  <div class="container">
    <div class="row">
      <div class="col-12 text-center">
        <h2 class="section-title">Contact Info</h2>
      </div>
      <div class="col-lg-8 mx-auto">
        <div class="bg-white rounded text-center p-5 shadow-down">
          <h4 class="mb-80">Contact Form</h4>
          <form action="https://formspree.io/olumideralph@gmail.com" method="POST" class="row">
            <div class="col-md-6">
              <input type="text" id="name" name="name" placeholder="Full Name" class="form-control px-0 mb-4" required>
            </div>
            <div class="col-md-6">
              <input type="email" id="email" name="email" placeholder="Email Address" class="form-control px-0 mb-4" required>
            </div>
            <div class="col-12">
              <textarea name="message" id="message" class="form-control px-0 mb-4"
                placeholder="Type Message Here" required></textarea>
            </div>
            <div class="col-lg-6 col-10 mx-auto">
              <button class="btn btn-primary w-100">send</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</section>




<footer class="bg-dark footer-section">
    <ul class="ml-5 mt-3 position-relative zindex-1">
        
        <li class="mb-3"><a class="text-white" href="https://linkedin.com/in/ogundeleolumide/"><i class="ti-linkedin"></i></a></li>
        
        <li class="mb-3"><a class="text-white" href="https://github.com/Lumexralph"><i class="ti-github"></i></a></li>
        
        <li class="mb-3"><a class="text-white" href="https://twitter.com/lumexralph"><i class="ti-twitter"></i></a></li>
        
      </ul>
  <div class="section">
    <div class="container">
      <div class="row">
        <div class="col-md-4">
          <h5 class="text-light">Email</h5>
          <p class="text-white paragraph-lg font-secondary">olumideralph@gmail.com</p>
        </div>
        
        <div class="col-md-4">
          <h5 class="text-light">Address</h5>
          <p class="text-white paragraph-lg font-secondary">Lagos, Nigeria</p>
        </div>
      </div>
    </div>
  </div>
  <div class="border-top text-center border-dark py-5">
    <p class="mb-0 text-light">Powered by <a href="https://themefisher.com/best-hugo-themes" target="blank">Hugo Themes</a></p>
  </div>
</footer>


<!-- Google Map API -->
<script src="https://lumexralph.github.io./"></script>
<!-- JS Plugins -->

<script src="https://lumexralph.github.io./plugins/jQuery/jquery.min.js"></script>

<script src="https://lumexralph.github.io./plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://lumexralph.github.io./plugins/slick/slick.min.js"></script>

<script src="https://lumexralph.github.io./plugins/shuffle/shuffle.min.js"></script>

<!-- Main Script -->

<script src="https://lumexralph.github.io./js/script.min.js"></script>
<!-- google analitycs -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-156681647-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>